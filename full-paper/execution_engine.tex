\section{\SeeDB Execution Engine}
\label{sec:optimizer}

As mentioned in the previous section, the \SeeDB execution engine is responsible for
evaluating the entire collection of potential visualizations and returning the top-$k$
visualizations in real-time.
To do so, it must apply aggressive optimization to minimize the number of queries to the
DBMS and avoid evaluation of low-utility views.

\subsection{Basic Implementation}
\label{sec:basic_implementation}

In the basic implementation of \SeeDB, for each aggregate view, \SeeDB generates
a SQL query corresponding to the target
and reference view, and issues
the two queries, one at a time, to the underlying DBMS.
It repeats this process for each aggregate view.
As the results are received, \SeeDB can compute the
distance between the target and reference view
distributions, and identify the $k$ visualizations
with highest utility. 

Naturally, this basic implementation has many inefficiencies.
In a table with $a$ dimensions, $m$ measures, and $f$ aggregation functions, 
$2\times f \times a \times  m$ queries must be executed independently.  
As we show in Section~\ref{sec:experiments}, this can take >100s for
large data sets (with hundreds of attributes and millions of rows).
These latencies are unacceptable for interactive use.
Next, we detail our {\em sharing-based} and {\em pruning-based} optimizations
that enable \SeeDB to respond to users in real-time.
\mpv{Remove:
In this paper, we propose two different suites of optimizations to deal with these
inefficiencies.
The first type of optimizations, discussed in Section~\ref{sec:sharing_opt}, involve work {\em sharing},
i.e., combining view-computation queries as much as possible.
The second type of optimizations, discussed in Section~\ref{sec:pruning_opt}, involve {\em pruning}, where some aggregate views are not completely evaluated over the whole data set.
 The second suite of optimizations
are approximate, in that they, since they use utility estimates, there is a small likelihood that the returned visualizations may not have the highest utility.}

\input{dbms_execution_engine.tex}
\input{in_memory_execution_engine.tex}