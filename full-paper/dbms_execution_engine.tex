%!TEX root=document.tex

\subsection{Sharing-based Optimizations}
\label{sec:sharing_opt}
In this section, we focus on minimizing total execution time
by reducing the
total number of queries issued to the database
and by reducing the total number of scans of the underlying table.
Sharing computation in our setting is a special case of the general problem
of multi-query optimization~\cite{DBLP:journals/tods/Sellis88}; we discuss the 
relationship in more detail in Section~\ref{sec:related_work}.
Specifically, we apply the following optimizations:

\stitle{Combine Multiple Aggregates}: Aggregate view queries 
with the same group-by attribute can be 
rewritten as a single query with multiple aggregations. 
So instead of executing
(queries for) views $(a_1$, $m_1$, $f_1)$, $(a_1$, $m_2$, $f_2)$ \ldots $(a_1$, $m_k$, $f_k)$
independently, \SeeDB combines them into a single view represented by
$(a_1, \{m_1, m_2\ldots m_k\}$, $\{f_1, f_2\ldots f_k\})$.  
We have found that there is minimal to no impact on latency 
for combining aggregates in both row and column stores. 

\stitle{Combine target and reference view query}:
Since the target view and reference views differ only in the subset of data
the query is executed on, \SeeDB rewrites these two view queries as
one. For instance, the target and reference view queries $Q1$ and $Q2$
shown below can be combined into a single query $Q3$.
\vspace{-5pt}
\begin{align*} 
Q1 = &{\tt SELECT \ } a, f(m) \ \ {\tt FROM} \  D\  {\tt WHERE \ \ x\ <\ 10\
GROUP \ \ BY} \ a \\
Q2 = &{\tt SELECT \ } a, f(m) \ \ {\tt FROM} \  D\  {\tt GROUP \ \ BY} \ a \\
Q3 = &{\tt SELECT \ } a, f(m), {\tt CASE\ IF\ x\ <\ 10\ THEN\ 1\ ELSE\ 0\
END}\\ 
&as\ g1,\ 1\ as\ g2 \ \ {\tt FROM} \ D\ {\tt GROUP \ \ BY} \ a,\ g1,\ g2
\end{align*}

\stitle {Parallel Query Execution}:
  \SeeDB executes multiple view queries in parallel since co-executing queries can often
 share buffer pool pages and reduce disk accesses times. 
  However, the precise number of parallel queries needs to be tuned to take into account 
  buffer pool contention, locking, and cache line contention, among others factors~\cite{Postgres_wiki}.  

\stitle {Combine Multiple GROUP BYs}:
\mpv{Review again.} After applying our multiple aggregates optimization, \SeeDB is left with a number of 
queries with multi-attribute aggregations but only single-attribute groupings.
These queries can be further combined to take advantage of multi-attribute grouping.
However, unlike combining multiple aggregates, the addition of a grouping attribute can 
significantly increase the number of groups that must be maintained and (possibly)
lead to slower overall performance for large number of groups.
We claim (and verify in Section \ref{sec:experiments}) that grouping can benefit 
performance so long as memory utilization for grouping stays under a threshold. 
% Therefore, \SeeDB has to determine the optimal way of combining multiple GROUP BY queries.
% Consequently, our specific problem is as follows: 
Given a memory budget $\mathcal{S}$,
and estimates of the number of distinct values for each attribute, we must determine the 
optimal grouping of single-attribute GROUP BY queries into multi-attribute GROUP BYs.
Note that knowledge of the number of distinct values for each attribute lets us estimate the
size of any view; for instance, the size of a view containing dimension attributes $a_i$ and $a_j$ 
can be estimated simply as $|a_i|\times |a_j|$.
Formally, our problem becomes:
\vspace{-5pt}
\begin{problem}[Optimal Grouping]
Given a set of dimension attributes $A$ = \{$a_1$\ldots$a_n$\}, divide the
dimension attributes in $A$ into groups $A_1, \ldots, A_l$ (where $A_i$ is some
subset of $A$ and $\bigcup A_i$=$A$) such that if a query $Q$ groups the table by $A_i$, 
the total space budget for $Q$ does not exceed $\mathcal{S}$.
\vspace{-5pt}
\end{problem}

Notice that the above problem is isomorphic to the NP-Hard {\em bin-packing} problem~\cite{garey}.
If we let each dimension attribute
$a_i$ correspond to an item in the bin-packing problem with weight $\log (|a_i|)$,
and set the bin size to be $\log \mathcal{S}$,
then packing items into bins is identical to finding groups $A_1, \ldots, A_l$,
such that the estimated size of any query result is below $\mathcal{S}$.
We use the standard first-fit algorithm~\cite{first-fit} to find the optimal
grouping of dimension attributes.

\stitle{Other Optimizations}: 
To further speedup processing, \SeeDB can also pre-compute results for 
static views (e.g. reference views on full tables) or operate on
pre-computed data samples.  Such optimizations are orthogonal to the
problem of efficiently evaluating a large number of views, which we must address
even in the presence of pre-computation or sampling.